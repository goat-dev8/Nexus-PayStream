You are working in D:\app\route\nexus-paystream-\.
There is an existing frontend at web/ generated by Lovable (Vite + React + TypeScript). Your job is to turn it into a real Polygon mainnet product called NEXUS PAYSTREAM:
Product features (must be real, no mocks):
this is DEPLOYER_PRIVATE_KEY=0xccdc85f19bb1145f2401eefe0dabba5d4e3a2fcf3aef9dd46a908a86e8c534f1    use it to deploy contract 
1. Merchant Registry: merchants register @username, payoutAddress, and stealthMetaAddress (ERC‑5564).
2. Private checkout: payer can pay USDC to a stealth address derived from merchant meta-address; app must also call the ERC‑5564 Announcer to emit the announcement event.
3. Invoices: create invoice records on-chain with only minimal data (token, amount, expiry, encrypted payload pointer).
4. Encrypted receipts: invoice details and receipts must be end-to-end encrypted in the browser (AES‑GCM). No plaintext on-chain.
5. Yield treasury (Wave 4 differentiator): merchant can deposit USDC into an ERC‑4626 vault that supplies to Aave V3 on Polygon (using PoolAddressesProvider).
6. Dashboard analytics: GMV, invoice status, conversion, etc. must be computed from on-chain events/logs (plus optional local caching).

Security rules:

* Never hardcode private keys in code.
* Never request me to paste secrets into chat.
* Use .env locally for secrets; .env.example with placeholders.
* Use wallet connections (wagmi/viem) in the browser for user actions.

Deliverables:

* Create contracts/ (Hardhat + TS), full tests, deploy scripts, Polygonscan verify scripts.
* Deploy to Polygon mainnet (chainId 137) and output web/src/config/deployments/polygon.json containing contract addresses + startBlock.
* Wire the frontend pages to real contracts and real chain reads.

Use these real addresses:

* USDC: 0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359
* ERC5564Announcer: 0x55649E01B5Df198D18D95b5cc5051630cfD45564
* Aave PoolAddressesProvider: 0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb


1) Make Copilot review the existing web/ code (so it stops guessing)
PROMPT 1 (WEB AUDIT):
Scan web/ and summarize:

* routing (all pages + paths),
* component structure,
* styling system (Tailwind? CSS modules?),
* state management,
* existing wallet/web3 libraries (if any),
* where best to add src/config, src/lib, and src/features/*.
Then propose a minimal integration plan that preserves the UI/animations.


2) Workspace + scripts (root + pnpm)
PROMPT 2 (MONOREPO SETUP):
Create a pnpm workspace at repo root:

* pnpm-workspace.yaml including web, contracts, packages/*
* root package.json with scripts:

dev (runs web)
contracts:test
contracts:deploy:polygon
contracts:verify:polygon
build
Add .gitignore for .env*, artifacts, cache, deployments, etc.
Do not break existing web scripts.




3) Contracts: keep it simple, event-driven, judge-friendly
PROMPT 3 (CONTRACTS IMPLEMENTATION):
Create contracts/ using Hardhat (TypeScript). Implement and test:
A) MerchantRegistry.sol

* registerMerchant(string username, address payout, bytes stealthMetaAddressBytes)
* updateMerchant(...)
* resolve(string username) returns (merchantId, payout, stealthMetaAddressBytes)
Events: MerchantRegistered, MerchantUpdated

B) InvoiceRegistry.sol
Store minimal invoice data:

* merchantId, token, amount, expiry, status
* encryptedDetailsPointer = bytes32 (commitment) OR string (CID)
Functions:
* createInvoice(merchantId, token, amount, expiry, encryptedPointer)
* markPaid(invoiceId, txHash, payer, paidAmount) (merchant action)
Events: InvoiceCreated, InvoicePaid, InvoiceExpired

C) TreasuryVaultUSDC.sol (ERC‑4626)

* asset = Polygon USDC
* deposits supply to Aave V3 Pool fetched from PoolAddressesProvider
* withdraw pulls from Aave
Expose totalAssets() correctly

Add full unit tests and fork tests where appropriate.

4) Deployment + verification + frontend address handoff
PROMPT 4 (DEPLOY PIPELINE):
Add:

* scripts/deployPolygon.ts deploys all contracts to Polygon mainnet
* writes web/src/config/deployments/polygon.json with:

chainId, addresses, startBlock, USDC address, announcer address, aave provider address


* scripts/verifyPolygon.ts (or hardhat-verify tasks) verifies contracts on PolygonScan using POLYGONSCAN_API_KEY
Also add .env.example in contracts/ and web/.

Important: deployment must read deployer key from process.env.DEPLOYER_PRIVATE_KEY only. Never hardcode it.

5) Environment files (real values + placeholders)
Create these files (Copilot should generate them):
contracts/.env.example
envDownloadCopy codePOLYGON_RPC_URL=https://polygon-rpc.com
DEPLOYER_PRIVATE_KEY=0xccdc85f19bb1145f2401eefe0dabba5d4e3a2fcf3aef9dd46a908a86e8c534f1
POLYGONSCAN_API_KEY=__PUT_YOUR_KEY_HERE__
web/.env.example
envDownloadCopy codeVITE_CHAIN_ID=137
VITE_POLYGON_RPC_URL=https://polygon-rpc.com
And in code, read the canonical addresses from web/src/config/deployments/polygon.json (not from random env vars).

6) Frontend Web3 wiring (wallet connect + reads + writes)
PROMPT 5 (WEB3 STACK):
In web/, add wagmi + viem + RainbowKit (or WalletConnect + wagmi). Configure Polygon mainnet chainId 137.
Implement:

* connect/disconnect UI wired to existing “Launch App” button
* publicClient reads for:

USDC balance (ERC20 balanceOf)
invoice events/logs
vault share balance + totalAssets



No mocks. Use the RPC from env as fallback, but prefer wagmi publicClient.

7) ERC‑5564 stealth payment (the “wow” feature)
PROMPT 6 (STEALTH PAY):
Implement ERC‑5564 flow on the checkout page:

* Resolve merchant by @username from MerchantRegistry
* Parse merchant stealthMetaAddress (bytes payload) and generate:

ephemeral key
stealth address
viewTag + metadata per ERC‑5564


* Execute USDC transfer to stealth address
* Call ERC5564Announcer.announce(...) so merchant can scan announcements.

Put all stealth logic in web/src/lib/stealth/* with strong TypeScript types and unit tests.
Use the ERC‑5564 standard and the announcer singleton address 0x55649E...5564. (eips.ethereum.org)

8) Merchant “scanner” view (so judges see it’s real)
PROMPT 7 (MERCHANT SCANNER + CLAIM):
Create a /dashboard/stealth page:

* Merchant signs a message to derive local “view/spend” keys (domain-separated) without storing anything server-side.
* Scan Announcement logs from the announcer contract from startBlock (from polygon.json).
* For each announcement, attempt to detect if it belongs to the merchant (using viewTag + shared secret).
* Show detected stealth addresses + USDC balances.
* Add a “Sweep” button:

constructs a tx signed by the derived stealth private key (in-memory only) sending USDC to merchant payout address.



Security UX: big warning + require explicit confirmation before deriving/sweeping keys.

9) Encrypted invoices + receipts (no plaintext)
PROMPT 8 (ENCRYPTED INVOICES):
Implement invoice creation:

* On /invoices/new, encrypt invoice JSON in-browser using AES‑GCM.
* Store ciphertext on IPFS (Pinata) using a JWT in web/.env.local (placeholder in .env.example).
* Store only CID (or bytes32 commitment) in InvoiceRegistry.
On /invoices/:id, fetch CID, decrypt locally, display details if user has the right key.

No demo data. If Pinata key is missing, block with a clear error and setup instructions.

10) Dashboard analytics from logs only
PROMPT 9 (ANALYTICS NO-MOCK):
Build dashboard metrics from:

* InvoiceRegistry events
* USDC Transfer logs to stealth addresses you detected (optional), and/or InvoicePaid events
Compute GMV, paid invoice count, conversion rate.
Cache computed results in localStorage with a block-number watermark, but always re-derive from chain logs as source of truth.